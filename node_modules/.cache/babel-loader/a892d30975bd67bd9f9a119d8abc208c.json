{"remainingRequest":"/Users/crocslut/Desktop/Git/primevue/node_modules/babel-loader/lib/index.js!/Users/crocslut/Desktop/Git/primevue/node_modules/cache-loader/dist/cjs.js??ref--0-0!/Users/crocslut/Desktop/Git/primevue/node_modules/vue-loader-v16/dist/index.js??ref--0-1!/Users/crocslut/Desktop/Git/primevue/src/views/treetable/TreeTableLazyDemo.vue?vue&type=script&lang=js","dependencies":[{"path":"/Users/crocslut/Desktop/Git/primevue/src/views/treetable/TreeTableLazyDemo.vue","mtime":1634633311636},{"path":"/Users/crocslut/Desktop/Git/primevue/node_modules/cache-loader/dist/cjs.js","mtime":1634631121968},{"path":"/Users/crocslut/Desktop/Git/primevue/node_modules/babel-loader/lib/index.js","mtime":1634631121902},{"path":"/Users/crocslut/Desktop/Git/primevue/node_modules/cache-loader/dist/cjs.js","mtime":1634631121968},{"path":"/Users/crocslut/Desktop/Git/primevue/node_modules/vue-loader-v16/dist/index.js","mtime":1634631132147}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9vYmplY3RTcHJlYWQgZnJvbSAiL1VzZXJzL2Nyb2NzbHV0L0Rlc2t0b3AvR2l0L3ByaW1ldnVlL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RTcHJlYWQyIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcC5qcyI7CmV4cG9ydCBkZWZhdWx0IHsKICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkgewogICAgcmV0dXJuIHsKICAgICAgbm9kZXM6IG51bGwsCiAgICAgIHJvd3M6IDEwLAogICAgICBsb2FkaW5nOiBmYWxzZSwKICAgICAgdG90YWxSZWNvcmRzOiAwLAogICAgICBzb3VyY2VzOiB7CiAgICAgICAgJ29wdGlvbnMtYXBpJzogewogICAgICAgICAgdGFiTmFtZTogJ09wdGlvbnMgQVBJIFNvdXJjZScsCiAgICAgICAgICBjb250ZW50OiAiXG48dGVtcGxhdGU+XG4gICAgPGRpdj5cbiAgICAgICAgPFRyZWVUYWJsZSA6dmFsdWU9XCJub2Rlc1wiIDpsYXp5PVwidHJ1ZVwiIDpwYWdpbmF0b3I9XCJ0cnVlXCIgOnJvd3M9XCJyb3dzXCIgOmxvYWRpbmc9XCJsb2FkaW5nXCJcbiAgICAgICAgICAgIEBub2RlRXhwYW5kPVwib25FeHBhbmRcIiBAcGFnZT1cIm9uUGFnZVwiIDp0b3RhbFJlY29yZHM9XCJ0b3RhbFJlY29yZHNcIj5cbiAgICAgICAgICAgIDxDb2x1bW4gZmllbGQ9XCJuYW1lXCIgaGVhZGVyPVwiTmFtZVwiIDpleHBhbmRlcj1cInRydWVcIj48L0NvbHVtbj5cbiAgICAgICAgICAgIDxDb2x1bW4gZmllbGQ9XCJzaXplXCIgaGVhZGVyPVwiU2l6ZVwiPjwvQ29sdW1uPlxuICAgICAgICAgICAgPENvbHVtbiBmaWVsZD1cInR5cGVcIiBoZWFkZXI9XCJUeXBlXCI+PC9Db2x1bW4+XG4gICAgICAgIDwvVHJlZVRhYmxlPlxuICAgIDwvZGl2PiAgICAgICAgICAgICAgICAgICBcbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5vZGVzOiBudWxsLFxuICAgICAgICAgICAgcm93czogMTAsXG4gICAgICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIHRvdGFsUmVjb3JkczogMFxuICAgICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkKCkge1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm5vZGVzID0gdGhpcy5sb2FkTm9kZXMoMCwgdGhpcy5yb3dzKTtcbiAgICAgICAgICAgIHRoaXMudG90YWxSZWNvcmRzID0gMTAwMDtcbiAgICAgICAgfSwgMTAwMCk7XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIG9uRXhwYW5kKG5vZGUpIHtcbiAgICAgICAgICAgIGlmICghbm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhenlOb2RlID0gey4uLm5vZGV9O1xuXG4gICAgICAgICAgICAgICAgICAgIGxhenlOb2RlLmNoaWxkcmVuID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbGF6eU5vZGUuZGF0YS5uYW1lICsgJyAtIDAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwKSArIDEgKyAna2InLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnRmlsZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGxhenlOb2RlLmRhdGEubmFtZSArICcgLSAxJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMCkgKyAxICsgJ2tiJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0ZpbGUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBub2RlcyA9IHRoaXMubm9kZXMubWFwKG4gPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4ua2V5ID09PSBub2RlLmtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBsYXp5Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVzID0gbm9kZXM7XG4gICAgICAgICAgICAgICAgfSwgMjUwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25QYWdlKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAvL2ltaXRhdGUgZGVsYXkgb2YgYSBiYWNrZW5kIGNhbGxcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMgPSB0aGlzLmxvYWROb2RlcyhldmVudC5maXJzdCwgdGhpcy5yb3dzKTtcbiAgICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICB9LFxuICAgICAgICBsb2FkTm9kZXMoZmlyc3QsIHJvd3MpIHtcbiAgICAgICAgICAgIGxldCBub2RlcyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogKGZpcnN0ICsgaSksXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdJdGVtICcgKyAoZmlyc3QgKyBpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDApICsgMSArICdrYicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnVHlwZSAnICsgKGZpcnN0ICsgaSlcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbGVhZjogZmFsc2VcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgICB9XG4gICAgfVxufVxuPFxcL3NjcmlwdD5cbiIKICAgICAgICB9LAogICAgICAgICdjb21wb3NpdGlvbi1hcGknOiB7CiAgICAgICAgICB0YWJOYW1lOiAnQ29tcG9zaXRpb24gQVBJIFNvdXJjZScsCiAgICAgICAgICBjb250ZW50OiAiXG48dGVtcGxhdGU+XG4gICAgPGRpdj5cbiAgICAgICAgPFRyZWVUYWJsZSA6dmFsdWU9XCJub2Rlc1wiIDpsYXp5PVwidHJ1ZVwiIDpwYWdpbmF0b3I9XCJ0cnVlXCIgOnJvd3M9XCJyb3dzXCIgOmxvYWRpbmc9XCJsb2FkaW5nXCJcbiAgICAgICAgICAgIEBub2RlRXhwYW5kPVwib25FeHBhbmRcIiBAcGFnZT1cIm9uUGFnZVwiIDp0b3RhbFJlY29yZHM9XCJ0b3RhbFJlY29yZHNcIj5cbiAgICAgICAgICAgIDxDb2x1bW4gZmllbGQ9XCJuYW1lXCIgaGVhZGVyPVwiTmFtZVwiIDpleHBhbmRlcj1cInRydWVcIj48L0NvbHVtbj5cbiAgICAgICAgICAgIDxDb2x1bW4gZmllbGQ9XCJzaXplXCIgaGVhZGVyPVwiU2l6ZVwiPjwvQ29sdW1uPlxuICAgICAgICAgICAgPENvbHVtbiBmaWVsZD1cInR5cGVcIiBoZWFkZXI9XCJUeXBlXCI+PC9Db2x1bW4+XG4gICAgICAgIDwvVHJlZVRhYmxlPlxuICAgIDwvZGl2PiAgICAgICAgICAgICAgICAgICBcbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyByZWYsIG9uTW91bnRlZCB9IGZyb20gJ3Z1ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBzZXR1cCgpIHtcbiAgICAgICAgb25Nb3VudGVkKCgpID0+IHtcbiAgICAgICAgICAgIGxvYWRpbmcudmFsdWUgPSB0cnVlO1xuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBsb2FkaW5nLnZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbm9kZXMudmFsdWUgPSBsb2FkTm9kZXMoMCwgcm93cy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgdG90YWxSZWNvcmRzLnZhbHVlID0gMTAwMDtcbiAgICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICB9KVxuICAgICAgICBjb25zdCBub2RlcyA9IHJlZigpO1xuICAgICAgICBjb25zdCByb3dzID0gcmVmKDEwKTtcbiAgICAgICAgY29uc3QgbG9hZGluZyA9IHJlZihmYWxzZSk7XG4gICAgICAgIGNvbnN0IHRvdGFsUmVjb3JkcyA9IHJlZigwKTtcbiAgICAgICAgY29uc3Qgb25FeHBhbmQgPSAobm9kZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgbG9hZGluZy52YWx1ZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhenlOb2RlID0gey4uLm5vZGV9O1xuXG4gICAgICAgICAgICAgICAgICAgIGxhenlOb2RlLmNoaWxkcmVuID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbGF6eU5vZGUuZGF0YS5uYW1lICsgJyAtIDAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwKSArIDEgKyAna2InLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnRmlsZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGxhenlOb2RlLmRhdGEubmFtZSArICcgLSAxJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMCkgKyAxICsgJ2tiJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0ZpbGUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdOb2RlcyA9IG5vZGVzLnZhbHVlLm1hcChuID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuLmtleSA9PT0gbm9kZS5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gbGF6eU5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBsb2FkaW5nLnZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnZhbHVlID0gbmV3Tm9kZXM7XG4gICAgICAgICAgICAgICAgfSwgMjUwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25QYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBsb2FkaW5nLnZhbHVlID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy9pbWl0YXRlIGRlbGF5IG9mIGEgYmFja2VuZCBjYWxsXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBsb2FkaW5nLnZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbm9kZXMudmFsdWUgPSBsb2FkTm9kZXMoZXZlbnQuZmlyc3QsIHJvd3MudmFsdWUpO1xuICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGxvYWROb2RlcyA9IChmaXJzdCwgcm93cykgPT4ge1xuICAgICAgICAgICAgbGV0IG5vZGVzID0gW107XG5cbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiAoZmlyc3QgKyBpKSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0l0ZW0gJyArIChmaXJzdCArIGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMCkgKyAxICsgJ2tiJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdUeXBlICcgKyAoZmlyc3QgKyBpKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBsZWFmOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBub2Rlcywgcm93cywgbG9hZGluZywgdG90YWxSZWNvcmRzLCBvbkV4cGFuZCwgb25QYWdlLCBsb2FkTm9kZXMgfVxuICAgIH1cbiAgICBcbn1cbjxcXC9zY3JpcHQ+XG4iCiAgICAgICAgfSwKICAgICAgICAnYnJvd3Nlci1zb3VyY2UnOiB7CiAgICAgICAgICB0YWJOYW1lOiAnQnJvd3NlciBTb3VyY2UnLAogICAgICAgICAgaW1wb3J0czogIjxzY3JpcHQgc3JjPVwiaHR0cHM6Ly91bnBrZy5jb20vcHJpbWV2dWVAXjMvdHJlZXRhYmxlL3RyZWV0YWJsZS5taW4uanNcIj48XFwvc2NyaXB0PlxuICAgICAgICA8c2NyaXB0IHNyYz1cImh0dHBzOi8vdW5wa2cuY29tL3ByaW1ldnVlQF4zL2NvbHVtbi9jb2x1bW4ubWluLmpzXCI+PFxcL3NjcmlwdD4iLAogICAgICAgICAgY29udGVudDogIjxkaXYgaWQ9XCJhcHBcIj5cbiAgICAgICAgICAgIDxwLXRyZWV0YWJsZSA6dmFsdWU9XCJub2Rlc1wiIDpsYXp5PVwidHJ1ZVwiIDpwYWdpbmF0b3I9XCJ0cnVlXCIgOnJvd3M9XCJyb3dzXCIgOmxvYWRpbmc9XCJsb2FkaW5nXCJcbiAgICAgICAgICAgICAgICBAbm9kZS1leHBhbmQ9XCJvbkV4cGFuZFwiIEBwYWdlPVwib25QYWdlXCIgOnRvdGFsLXJlY29yZHM9XCJ0b3RhbFJlY29yZHNcIj5cbiAgICAgICAgICAgICAgICA8cC1jb2x1bW4gZmllbGQ9XCJuYW1lXCIgaGVhZGVyPVwiTmFtZVwiIDpleHBhbmRlcj1cInRydWVcIj48L3AtY29sdW1uPlxuICAgICAgICAgICAgICAgIDxwLWNvbHVtbiBmaWVsZD1cInNpemVcIiBoZWFkZXI9XCJTaXplXCI+PC9wLWNvbHVtbj5cbiAgICAgICAgICAgICAgICA8cC1jb2x1bW4gZmllbGQ9XCJ0eXBlXCIgaGVhZGVyPVwiVHlwZVwiPjwvcC1jb2x1bW4+XG4gICAgICAgICAgICA8L3AtdHJlZXRhYmxlPlxuICAgICAgICA8L2Rpdj4gICAgICAgICAgICAgICAgICAgXG5cbiAgICAgICAgPHNjcmlwdCB0eXBlPVwibW9kdWxlXCI+XG4gICAgICAgIGNvbnN0IHsgY3JlYXRlQXBwLCByZWYsIG9uTW91bnRlZCB9ID0gVnVlO1xuXG4gICAgICAgIGNvbnN0IEFwcCA9IHtcbiAgICAgICAgICAgIHNldHVwKCkge1xuICAgICAgICAgICAgICAgIG9uTW91bnRlZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRpbmcudmFsdWUgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGluZy52YWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMudmFsdWUgPSBsb2FkTm9kZXMoMCwgcm93cy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFJlY29yZHMudmFsdWUgPSAxMDAwO1xuICAgICAgICAgICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gcmVmKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm93cyA9IHJlZigxMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9hZGluZyA9IHJlZihmYWxzZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdG90YWxSZWNvcmRzID0gcmVmKDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uRXhwYW5kID0gKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkaW5nLnZhbHVlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxhenlOb2RlID0gey4uLm5vZGV9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF6eU5vZGUuY2hpbGRyZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBsYXp5Tm9kZS5kYXRhLm5hbWUgKyAnIC0gMCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMCkgKyAxICsgJ2tiJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnRmlsZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBsYXp5Tm9kZS5kYXRhLm5hbWUgKyAnIC0gMScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMCkgKyAxICsgJ2tiJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnRmlsZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3Tm9kZXMgPSBub2Rlcy52YWx1ZS5tYXAobiA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuLmtleSA9PT0gbm9kZS5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBsYXp5Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGluZy52YWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnZhbHVlID0gbmV3Tm9kZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAyNTApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBvblBhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZy52YWx1ZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9pbWl0YXRlIGRlbGF5IG9mIGEgYmFja2VuZCBjYWxsXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGluZy52YWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMudmFsdWUgPSBsb2FkTm9kZXMoZXZlbnQuZmlyc3QsIHJvd3MudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvYWROb2RlcyA9IChmaXJzdCwgcm93cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZXMgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IChmaXJzdCArIGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0l0ZW0gJyArIChmaXJzdCArIGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwKSArIDEgKyAna2InLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnVHlwZSAnICsgKGZpcnN0ICsgaSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlYWY6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB7IG5vZGVzLCByb3dzLCBsb2FkaW5nLCB0b3RhbFJlY29yZHMsIG9uRXhwYW5kLCBvblBhZ2UsIGxvYWROb2RlcyB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29tcG9uZW50czoge1xuICAgICAgICAgICAgICAgIFwicC10cmVldGFibGVcIjogcHJpbWV2dWUudHJlZXRhYmxlLFxuICAgICAgICAgICAgICAgIFwicC1jb2x1bW5cIjogcHJpbWV2dWUuY29sdW1uXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBjcmVhdGVBcHAoQXBwKVxuICAgICAgICAgICAgLnVzZShwcmltZXZ1ZS5jb25maWcuZGVmYXVsdClcbiAgICAgICAgICAgIC5tb3VudChcIiNhcHBcIik7XG4gICAgICAgIDxcXC9zY3JpcHQ+XG4iCiAgICAgICAgfQogICAgICB9CiAgICB9OwogIH0sCiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHsKICAgIHZhciBfdGhpcyA9IHRoaXM7CgogICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgewogICAgICBfdGhpcy5sb2FkaW5nID0gZmFsc2U7CiAgICAgIF90aGlzLm5vZGVzID0gX3RoaXMubG9hZE5vZGVzKDAsIF90aGlzLnJvd3MpOwogICAgICBfdGhpcy50b3RhbFJlY29yZHMgPSAxMDAwOwogICAgfSwgMTAwMCk7CiAgfSwKICBtZXRob2RzOiB7CiAgICBvbkV4cGFuZDogZnVuY3Rpb24gb25FeHBhbmQobm9kZSkgewogICAgICB2YXIgX3RoaXMyID0gdGhpczsKCiAgICAgIGlmICghbm9kZS5jaGlsZHJlbikgewogICAgICAgIHRoaXMubG9hZGluZyA9IHRydWU7CiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7CiAgICAgICAgICB2YXIgbGF6eU5vZGUgPSBfb2JqZWN0U3ByZWFkKHt9LCBub2RlKTsKCiAgICAgICAgICBsYXp5Tm9kZS5jaGlsZHJlbiA9IFt7CiAgICAgICAgICAgIGRhdGE6IHsKICAgICAgICAgICAgICBuYW1lOiBsYXp5Tm9kZS5kYXRhLm5hbWUgKyAnIC0gMCcsCiAgICAgICAgICAgICAgc2l6ZTogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMCkgKyAxICsgJ2tiJywKICAgICAgICAgICAgICB0eXBlOiAnRmlsZScKICAgICAgICAgICAgfQogICAgICAgICAgfSwgewogICAgICAgICAgICBkYXRhOiB7CiAgICAgICAgICAgICAgbmFtZTogbGF6eU5vZGUuZGF0YS5uYW1lICsgJyAtIDEnLAogICAgICAgICAgICAgIHNpemU6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDApICsgMSArICdrYicsCiAgICAgICAgICAgICAgdHlwZTogJ0ZpbGUnCiAgICAgICAgICAgIH0KICAgICAgICAgIH1dOwoKICAgICAgICAgIHZhciBub2RlcyA9IF90aGlzMi5ub2Rlcy5tYXAoZnVuY3Rpb24gKG4pIHsKICAgICAgICAgICAgaWYgKG4ua2V5ID09PSBub2RlLmtleSkgewogICAgICAgICAgICAgIG4gPSBsYXp5Tm9kZTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgcmV0dXJuIG47CiAgICAgICAgICB9KTsKCiAgICAgICAgICBfdGhpczIubG9hZGluZyA9IGZhbHNlOwogICAgICAgICAgX3RoaXMyLm5vZGVzID0gbm9kZXM7CiAgICAgICAgfSwgMjUwKTsKICAgICAgfQogICAgfSwKICAgIG9uUGFnZTogZnVuY3Rpb24gb25QYWdlKGV2ZW50KSB7CiAgICAgIHZhciBfdGhpczMgPSB0aGlzOwoKICAgICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTsgLy9pbWl0YXRlIGRlbGF5IG9mIGEgYmFja2VuZCBjYWxsCgogICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsKICAgICAgICBfdGhpczMubG9hZGluZyA9IGZhbHNlOwogICAgICAgIF90aGlzMy5ub2RlcyA9IF90aGlzMy5sb2FkTm9kZXMoZXZlbnQuZmlyc3QsIF90aGlzMy5yb3dzKTsKICAgICAgfSwgMTAwMCk7CiAgICB9LAogICAgbG9hZE5vZGVzOiBmdW5jdGlvbiBsb2FkTm9kZXMoZmlyc3QsIHJvd3MpIHsKICAgICAgdmFyIG5vZGVzID0gW107CgogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd3M7IGkrKykgewogICAgICAgIHZhciBub2RlID0gewogICAgICAgICAga2V5OiBmaXJzdCArIGksCiAgICAgICAgICBkYXRhOiB7CiAgICAgICAgICAgIG5hbWU6ICdJdGVtICcgKyAoZmlyc3QgKyBpKSwKICAgICAgICAgICAgc2l6ZTogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMCkgKyAxICsgJ2tiJywKICAgICAgICAgICAgdHlwZTogJ1R5cGUgJyArIChmaXJzdCArIGkpCiAgICAgICAgICB9LAogICAgICAgICAgbGVhZjogZmFsc2UKICAgICAgICB9OwogICAgICAgIG5vZGVzLnB1c2gobm9kZSk7CiAgICAgIH0KCiAgICAgIHJldHVybiBub2RlczsKICAgIH0KICB9Cn07"},{"version":3,"sources":["/Users/crocslut/Desktop/Git/primevue/src/views/treetable/TreeTableLazyDemo.vue"],"names":[],"mappings":"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","sourcesContent":["<template>\n    <div>\n        <div class=\"content-section introduction\">\n            <div class=\"feature-intro\">\n                <h1>TreeTable <span>Lazy</span></h1>\n                <p>Lazy mode is handy to deal with large datasets, instead of loading the entire data, small chunks of data is loaded by invoking corresponding callbacks everytime paging or sorting. In addition,\n                    children of a node can be loaded on demand at onNodeExpand event as well. Sample belows imitates lazy paging by using an in memory list..</p>\n            </div>\n            <AppDemoActions />\n        </div>\n\n        <div class=\"content-section implementation\">\n            <div class=\"card\">\n                <TreeTable :value=\"nodes\" :lazy=\"true\" :paginator=\"true\" :rows=\"rows\" :loading=\"loading\"\n                    @node-expand=\"onExpand\" @page=\"onPage\" :totalRecords=\"totalRecords\">\n                    <Column field=\"name\" header=\"Name\" :expander=\"true\"></Column>\n                    <Column field=\"size\" header=\"Size\"></Column>\n                    <Column field=\"type\" header=\"Type\"></Column>\n                </TreeTable>\n            </div>\n        </div>\n\n        <AppDoc name=\"TreeTableLazyDemo\" :sources=\"sources\" :service=\"['NodeService']\" :data=\"['treetablenodes']\" github=\"treetable/TreeTableLazyDemo.vue\" />\n    </div>\n</template>\n\n<script>\nexport default {\n    data() {\n        return {\n            nodes: null,\n            rows: 10,\n            loading: false,\n            totalRecords: 0,\n            sources: {\n                'options-api': {\n                    tabName: 'Options API Source',\n                    content: `\n<template>\n    <div>\n        <TreeTable :value=\"nodes\" :lazy=\"true\" :paginator=\"true\" :rows=\"rows\" :loading=\"loading\"\n            @nodeExpand=\"onExpand\" @page=\"onPage\" :totalRecords=\"totalRecords\">\n            <Column field=\"name\" header=\"Name\" :expander=\"true\"></Column>\n            <Column field=\"size\" header=\"Size\"></Column>\n            <Column field=\"type\" header=\"Type\"></Column>\n        </TreeTable>\n    </div>                   \n</template>\n\n<script>\nexport default {\n    data() {\n        return {\n            nodes: null,\n            rows: 10,\n            loading: false,\n            totalRecords: 0\n        }\n    },\n    mounted() {\n        this.loading = true;\n\n        setTimeout(() => {\n            this.loading = false;\n            this.nodes = this.loadNodes(0, this.rows);\n            this.totalRecords = 1000;\n        }, 1000);\n    },\n    methods: {\n        onExpand(node) {\n            if (!node.children) {\n                this.loading = true;\n\n                setTimeout(() => {\n                    let lazyNode = {...node};\n\n                    lazyNode.children = [\n                        {\n                            data: {\n                                name: lazyNode.data.name + ' - 0',\n                                size: Math.floor(Math.random() * 1000) + 1 + 'kb',\n                                type: 'File'\n                            },\n                        },\n                        {\n                            data: {\n                                name: lazyNode.data.name + ' - 1',\n                                size: Math.floor(Math.random() * 1000) + 1 + 'kb',\n                                type: 'File'\n                            }\n                        }\n                    ];\n\n                    let nodes = this.nodes.map(n => {\n                        if (n.key === node.key) {\n                            n = lazyNode;\n                        }\n\n                        return n;\n                    });\n\n                    this.loading = false;\n                    this.nodes = nodes;\n                }, 250);\n            }\n        },\n        onPage(event) {\n            this.loading = true;\n\n            //imitate delay of a backend call\n            setTimeout(() => {\n                this.loading = false;\n                this.nodes = this.loadNodes(event.first, this.rows);\n            }, 1000);\n        },\n        loadNodes(first, rows) {\n            let nodes = [];\n\n            for(let i = 0; i < rows; i++) {\n                let node = {\n                    key: (first + i),\n                    data: {\n                        name: 'Item ' + (first + i),\n                        size: Math.floor(Math.random() * 1000) + 1 + 'kb',\n                        type: 'Type ' + (first + i)\n                    },\n                    leaf: false\n                };\n\n                nodes.push(node);\n            }\n\n            return nodes;\n        }\n    }\n}\n<\\\\/script>\n`\n                },\n                'composition-api': {\n                    tabName: 'Composition API Source',\n                    content: `\n<template>\n    <div>\n        <TreeTable :value=\"nodes\" :lazy=\"true\" :paginator=\"true\" :rows=\"rows\" :loading=\"loading\"\n            @nodeExpand=\"onExpand\" @page=\"onPage\" :totalRecords=\"totalRecords\">\n            <Column field=\"name\" header=\"Name\" :expander=\"true\"></Column>\n            <Column field=\"size\" header=\"Size\"></Column>\n            <Column field=\"type\" header=\"Type\"></Column>\n        </TreeTable>\n    </div>                   \n</template>\n\n<script>\nimport { ref, onMounted } from 'vue';\n\nexport default {\n    setup() {\n        onMounted(() => {\n            loading.value = true;\n\n            setTimeout(() => {\n                loading.value = false;\n                nodes.value = loadNodes(0, rows.value);\n                totalRecords.value = 1000;\n            }, 1000);\n        })\n        const nodes = ref();\n        const rows = ref(10);\n        const loading = ref(false);\n        const totalRecords = ref(0);\n        const onExpand = (node) => {\n            if (!node.children) {\n                loading.value = true;\n\n                setTimeout(() => {\n                    let lazyNode = {...node};\n\n                    lazyNode.children = [\n                        {\n                            data: {\n                                name: lazyNode.data.name + ' - 0',\n                                size: Math.floor(Math.random() * 1000) + 1 + 'kb',\n                                type: 'File'\n                            },\n                        },\n                        {\n                            data: {\n                                name: lazyNode.data.name + ' - 1',\n                                size: Math.floor(Math.random() * 1000) + 1 + 'kb',\n                                type: 'File'\n                            }\n                        }\n                    ];\n\n                    let newNodes = nodes.value.map(n => {\n                        if (n.key === node.key) {\n                            n = lazyNode;\n                        }\n\n                        return n;\n                    });\n\n                    loading.value = false;\n                    nodes.value = newNodes;\n                }, 250);\n            }\n        };\n        const onPage = (event) => {\n            loading.value = true;\n\n            //imitate delay of a backend call\n            setTimeout(() => {\n                loading.value = false;\n                nodes.value = loadNodes(event.first, rows.value);\n            }, 1000);\n        };\n        const loadNodes = (first, rows) => {\n            let nodes = [];\n\n            for(let i = 0; i < rows; i++) {\n                let node = {\n                    key: (first + i),\n                    data: {\n                        name: 'Item ' + (first + i),\n                        size: Math.floor(Math.random() * 1000) + 1 + 'kb',\n                        type: 'Type ' + (first + i)\n                    },\n                    leaf: false\n                };\n\n                nodes.push(node);\n            }\n\n            return nodes;\n        }\n\n        return { nodes, rows, loading, totalRecords, onExpand, onPage, loadNodes }\n    }\n    \n}\n<\\\\/script>\n`\n                },\n                'browser-source': {\n                    tabName: 'Browser Source',\n                    imports: `<script src=\"https://unpkg.com/primevue@^3/treetable/treetable.min.js\"><\\\\/script>\n        <script src=\"https://unpkg.com/primevue@^3/column/column.min.js\"><\\\\/script>`,\n                    content: `<div id=\"app\">\n            <p-treetable :value=\"nodes\" :lazy=\"true\" :paginator=\"true\" :rows=\"rows\" :loading=\"loading\"\n                @node-expand=\"onExpand\" @page=\"onPage\" :total-records=\"totalRecords\">\n                <p-column field=\"name\" header=\"Name\" :expander=\"true\"></p-column>\n                <p-column field=\"size\" header=\"Size\"></p-column>\n                <p-column field=\"type\" header=\"Type\"></p-column>\n            </p-treetable>\n        </div>                   \n\n        <script type=\"module\">\n        const { createApp, ref, onMounted } = Vue;\n\n        const App = {\n            setup() {\n                onMounted(() => {\n                    loading.value = true;\n\n                    setTimeout(() => {\n                        loading.value = false;\n                        nodes.value = loadNodes(0, rows.value);\n                        totalRecords.value = 1000;\n                    }, 1000);\n                })\n                const nodes = ref();\n                const rows = ref(10);\n                const loading = ref(false);\n                const totalRecords = ref(0);\n                const onExpand = (node) => {\n                    if (!node.children) {\n                        loading.value = true;\n\n                        setTimeout(() => {\n                            let lazyNode = {...node};\n\n                            lazyNode.children = [\n                                {\n                                    data: {\n                                        name: lazyNode.data.name + ' - 0',\n                                        size: Math.floor(Math.random() * 1000) + 1 + 'kb',\n                                        type: 'File'\n                                    },\n                                },\n                                {\n                                    data: {\n                                        name: lazyNode.data.name + ' - 1',\n                                        size: Math.floor(Math.random() * 1000) + 1 + 'kb',\n                                        type: 'File'\n                                    }\n                                }\n                            ];\n\n                            let newNodes = nodes.value.map(n => {\n                                if (n.key === node.key) {\n                                    n = lazyNode;\n                                }\n\n                                return n;\n                            });\n\n                            loading.value = false;\n                            nodes.value = newNodes;\n                        }, 250);\n                    }\n                };\n                const onPage = (event) => {\n                    loading.value = true;\n\n                    //imitate delay of a backend call\n                    setTimeout(() => {\n                        loading.value = false;\n                        nodes.value = loadNodes(event.first, rows.value);\n                    }, 1000);\n                };\n                const loadNodes = (first, rows) => {\n                    let nodes = [];\n\n                    for(let i = 0; i < rows; i++) {\n                        let node = {\n                            key: (first + i),\n                            data: {\n                                name: 'Item ' + (first + i),\n                                size: Math.floor(Math.random() * 1000) + 1 + 'kb',\n                                type: 'Type ' + (first + i)\n                            },\n                            leaf: false\n                        };\n\n                        nodes.push(node);\n                    }\n\n                    return nodes;\n                }\n\n                return { nodes, rows, loading, totalRecords, onExpand, onPage, loadNodes }\n            },\n            components: {\n                \"p-treetable\": primevue.treetable,\n                \"p-column\": primevue.column\n            }\n        };\n        \n        createApp(App)\n            .use(primevue.config.default)\n            .mount(\"#app\");\n        <\\\\/script>\n`\n                }\n            }\n        }\n    },\n    mounted() {\n        this.loading = true;\n\n        setTimeout(() => {\n            this.loading = false;\n            this.nodes = this.loadNodes(0, this.rows);\n            this.totalRecords = 1000;\n        }, 1000);\n    },\n    methods: {\n        onExpand(node) {\n            if (!node.children) {\n                this.loading = true;\n\n                setTimeout(() => {\n                    let lazyNode = {...node};\n\n                    lazyNode.children = [\n                        {\n                            data: {\n                                name: lazyNode.data.name + ' - 0',\n                                size: Math.floor(Math.random() * 1000) + 1 + 'kb',\n                                type: 'File'\n                            },\n                        },\n                        {\n                            data: {\n                                name: lazyNode.data.name + ' - 1',\n                                size: Math.floor(Math.random() * 1000) + 1 + 'kb',\n                                type: 'File'\n                            }\n                        }\n                    ];\n\n                    let nodes = this.nodes.map(n => {\n                        if (n.key === node.key) {\n                            n = lazyNode;\n                        }\n\n                        return n;\n                    });\n\n                    this.loading = false;\n                    this.nodes = nodes;\n                }, 250);\n            }\n        },\n        onPage(event) {\n            this.loading = true;\n\n            //imitate delay of a backend call\n            setTimeout(() => {\n                this.loading = false;\n                this.nodes = this.loadNodes(event.first, this.rows);\n            }, 1000);\n        },\n        loadNodes(first, rows) {\n            let nodes = [];\n\n            for(let i = 0; i < rows; i++) {\n                let node = {\n                    key: (first + i),\n                    data: {\n                        name: 'Item ' + (first + i),\n                        size: Math.floor(Math.random() * 1000) + 1 + 'kb',\n                        type: 'Type ' + (first + i)\n                    },\n                    leaf: false\n                };\n\n                nodes.push(node);\n            }\n\n            return nodes;\n        }\n    }\n}\n</script>"],"sourceRoot":""}]}